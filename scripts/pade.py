import datetime
from pathlib import Path

from sympy import Float, Matrix, Pow, eye, factorial, zeros
from tqdm import trange

_APPROXIMANTS = """/* This file was autogenerated on {date_and_time} DO NOT EDIT! */

#pragma once

#include <array>
#include <utility>

namespace pade {{
template <auto M, auto N, auto order>
inline constexpr auto
approximant(double* ys, double x, size_t offset) -> void;

template <auto M, auto N, auto... indices>
inline constexpr auto
compute_approximants(std::index_sequence<indices...>, double* ys, double x, size_t offset) -> void
{{
    (approximant<M, N, indices + 1>(ys, x, offset), ...);
}}
}}  // namespace pade

{lines}
"""

_COEFFICIENTS = """/* This file was autogenerated on {date_and_time} DO NOT EDIT! */

#pragma once

#include <array>

#include \"HornerScheme.hpp\"

namespace pade {{
/**@{{ [{P}/{Q}] Pad√© approximant coefficients for Boys function of orders 1 <= O <= {max_order}.*/
{lines}
/**@}}*/
}}  // namespace pade
"""

_LINES = """
template <>
inline constexpr auto approximant<{P}, {Q}, {order}ul>(double * ys, double x, size_t offset) -> void
{{
    ys[{order} + offset] = horner(x, {ps}) / horner(x, {qs});
}}
"""

_CPP = """/* This file was autogenerated on {date_and_time} DO NOT EDIT! */

#include <stdexcept>
#include <string>
#include <vector>

#include "Pade.hpp"
#include "Utilities.hpp"

namespace pade {{
{functions}
}}  // namespace pade
"""

_FUNCTIONS = """auto
boys_function_{P}_{Q}(size_t order, const std::vector<double>& xs) -> std::vector<double>
{{
    switch (order)
    {{
       case 0:
           return boys_function_0(xs);
       {lines}
       default:
           throw std::invalid_argument("Maximum supported order is {max_order}. Requested order is " + std::to_string(order));
    }}
}}
"""


def _boys_taylor_coeffs(*, j, k_max):
    return Matrix(
        k_max,
        1,
        lambda i, _: Pow(-1, i) / ((2 * j + 2 * i + 1) * factorial(i)),
    )


def _pade(an, *, deg_den: int, deg_num: int):
    if deg_num < 0 or deg_den < 0:
        raise ValueError("Order of p/q must be greater than 0.")

    N = deg_den + deg_num
    if N > len(an) - 1:
        raise ValueError("Order of q+p <m+n> must be smaller than len(an).")

    an = Matrix(an[: N + 1])
    Akj = eye(N + 1, deg_num + 1)
    Bkj = zeros(N + 1, deg_den)

    for row in range(1, deg_den + 1):
        Bkj[row, :row] = [(an[:row])[::-1]]

    for row in range(deg_den + 1, N + 1):
        Bkj[row, :] = [(an[row - deg_den : row])[::-1]]

    C = Akj.row_join(-Bkj)
    pq = C.LUsolve(an)
    p = pq[: deg_num + 1]
    q = pq[deg_num + 1 :]
    q.insert(0, Float(1))

    return p, q


def generate(folder: Path, *, max_order: int, P: int, Q: int) -> None:
    date_and_time = datetime.datetime.now().isoformat(timespec="minutes")

    # generate CMakeLists.txt
    with Path(folder / "CMakeLists.txt").open("w") as fh:
        fh.write(
            f"""# This file was autogenerated on {date_and_time} DO NOT EDIT!

target_sources(run PRIVATE Pade.cpp)
        """
        )

    # generate include file with interface
    with Path(folder / "Approximants.hpp").open("w") as fh:
        fh.write(
            _APPROXIMANTS.format(
                date_and_time=date_and_time,
                max_order=max_order,
                lines="\n".join(
                    [
                        f'#include "approximants/Coefficients_{P:02d}_{Q:02d}.hpp"'
                        for P, Q in [(5, 6), (9, 10), (15, 16), (25, 26)]
                    ]
                ),
            )
        )

    # generate source file
    with Path(folder / "Pade.cpp").open("w") as fh:
        functions = []
        for P, Q in [(5, 6), (9, 10), (15, 16), (25, 26)]:
            functions.append(
                _FUNCTIONS.format(
                    max_order=max_order,
                    P=P,
                    Q=Q,
                    lines="\n".join(
                        [
                            f"case {n}:\n    return cpu::boys_function<{P}, {Q}, {n}>(xs);"
                            for n in range(1, max_order + 1)
                        ]
                    ),
                )
            )

        fh.write(
            _CPP.format(date_and_time=date_and_time, functions="\n".join(functions))
        )

    (folder / "approximants").mkdir(parents=True, exist_ok=True)

    lines = []
    for n in trange(1, max_order + 1):
        Ps, Qs = _pade(_boys_taylor_coeffs(j=n, k_max=60), deg_den=Q, deg_num=P)

        lines.append(
            _LINES.format(
                P=P,
                Q=Q,
                order=n,
                ps=", ".join([format(_.evalf(30), "3.20e") for _ in Ps]),
                qs=", ".join([format(_.evalf(30), "3.20e") for _ in Qs]),
            )
        )

        with (folder / f"approximants/Coefficients_{P:02d}_{Q:02d}.hpp").open(
            "w"
        ) as fh:
            fh.write(
                _COEFFICIENTS.format(
                    date_and_time=date_and_time,
                    P=P,
                    Q=Q,
                    max_order=max_order,
                    len_Ps=len(Ps),
                    len_Qs=len(Qs),
                    lines="\n".join(lines),
                )
            )
